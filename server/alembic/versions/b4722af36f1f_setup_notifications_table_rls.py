"""setup_notifications_table_rls

Revision ID: b4722af36f1f
Revises: add_content_html_materials
Create Date: 2025-11-19 13:11:38.757641

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'b4722af36f1f'
down_revision: Union[str, Sequence[str], None] = 'add_content_html_materials'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def _exec_if_table(table: str, statements: list[str]) -> None:
    """Execute each statement via EXECUTE only when the table exists."""
    escaped = [stmt.replace("'", "''") for stmt in statements]
    exec_lines = "\n            ".join(f"EXECUTE '{stmt}';" for stmt in escaped)
    op.execute(
        f"""
        DO $$
        BEGIN
            IF to_regclass('public."{table}"') IS NOT NULL THEN
                {exec_lines}
            END IF;
        END
        $$;
        """
    )


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_item_bank_id'), table_name='item_bank')
    op.drop_table('item_bank')
    op.drop_index(op.f('ix_test_statistics_id'), table_name='test_statistics')
    op.drop_index(op.f('ix_test_statistics_subject_id'), table_name='test_statistics')
    op.drop_index(op.f('ix_test_statistics_test_id'), table_name='test_statistics')
    op.drop_table('test_statistics')
    op.drop_index(op.f('ix_user_role_assignments_id'), table_name='user_role_assignments')
    op.drop_table('user_role_assignments')
    op.drop_index(op.f('ix_student_progress_id'), table_name='student_progress')
    op.drop_index(op.f('ix_student_progress_subject_id'), table_name='student_progress')
    op.drop_index(op.f('ix_student_progress_user_id'), table_name='student_progress')
    op.drop_table('student_progress')
    op.drop_index(op.f('ix_subjects_id'), table_name='subjects')
    op.drop_table('subjects')
    op.drop_index(op.f('ix_test_results_id'), table_name='test_results')
    op.drop_index(op.f('ix_test_results_test_id'), table_name='test_results')
    op.drop_index(op.f('ix_test_results_user_id'), table_name='test_results')
    op.drop_table('test_results')
    op.alter_column('assessment_results', 'is_quick_test',
               existing_type=sa.BOOLEAN(),
               nullable=True,
               existing_server_default=sa.text('false'))
    op.alter_column('library_documents', 'rating_sum',
               existing_type=sa.INTEGER(),
               nullable=True,
               existing_server_default=sa.text('0'))
    # ### end Alembic commands ###
    
    # Update notificationtype enum to include 'system' if it doesn't exist
    op.execute("""
        DO $$
        BEGIN
            -- Check if 'system' value exists in enum
            IF NOT EXISTS (
                SELECT 1 FROM pg_enum 
                WHERE enumlabel = 'system' 
                AND enumtypid = (
                    SELECT oid FROM pg_type WHERE typname = 'notificationtype'
                )
            ) THEN
                -- Add 'system' to the enum
                ALTER TYPE notificationtype ADD VALUE IF NOT EXISTS 'system';
            END IF;
        END $$;
    """)
    
    # Setup RLS for notifications table
    # Note: Service role key bypasses RLS, but we still need policies for regular users
    _exec_if_table(
        "notifications",
        [
            'ALTER TABLE public."notifications" ENABLE ROW LEVEL SECURITY',
            # Allow users to read their own notifications
            "DROP POLICY IF EXISTS notifications_select_own ON public.notifications",
            "CREATE POLICY notifications_select_own ON public.notifications "
            "FOR SELECT USING (auth.uid() = user_id_target)",
            # Allow users to update their own notifications (mark as read)
            "DROP POLICY IF EXISTS notifications_update_own ON public.notifications",
            "CREATE POLICY notifications_update_own ON public.notifications "
            "FOR UPDATE USING (auth.uid() = user_id_target) WITH CHECK (auth.uid() = user_id_target)",
            # Allow service role to insert (bypasses RLS automatically, but explicit policy for clarity)
            # Service role key bypasses RLS, so this is mainly for documentation
            "DROP POLICY IF EXISTS notifications_service_insert ON public.notifications",
            "CREATE POLICY notifications_service_insert ON public.notifications "
            "FOR INSERT WITH CHECK (true)",  # Service role bypasses this anyway
        ],
    )


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('library_documents', 'rating_sum',
               existing_type=sa.INTEGER(),
               nullable=False,
               existing_server_default=sa.text('0'))
    op.alter_column('assessment_results', 'is_quick_test',
               existing_type=sa.BOOLEAN(),
               nullable=False,
               existing_server_default=sa.text('false'))
    op.create_table('test_results',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('test_id', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('test_title', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('subject_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('subject_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('total_questions', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('answered_questions', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('correct_answers', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('total_points', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('earned_points', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('percentage', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('grade', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('time_limit', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('time_taken', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('status', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('is_passed', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('attempt_number', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('max_attempts', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('passing_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('started_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('completed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('ip_address', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('user_agent', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('answers', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name=op.f('test_results_user_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('test_results_pkey'))
    )
    op.create_index(op.f('ix_test_results_user_id'), 'test_results', ['user_id'], unique=False)
    op.create_index(op.f('ix_test_results_test_id'), 'test_results', ['test_id'], unique=False)
    op.create_index(op.f('ix_test_results_id'), 'test_results', ['id'], unique=False)
    op.create_table('subjects',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('name', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('description', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('domain_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('class_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['class_id'], ['classes.id'], name=op.f('subjects_class_id_fkey')),
    sa.ForeignKeyConstraint(['domain_id'], ['domains.id'], name=op.f('subjects_domain_id_fkey')),
    sa.PrimaryKeyConstraint('id', name=op.f('subjects_pkey'))
    )
    op.create_index(op.f('ix_subjects_id'), 'subjects', ['id'], unique=False)
    op.create_table('student_progress',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('subject_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('subject_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('instructor_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('total_tests', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('completed_tests', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('passed_tests', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('failed_tests', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('average_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('best_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('latest_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('improvement_trend', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('total_study_time', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('average_test_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('first_attempt', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('last_attempt', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('weak_topics', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('strong_topics', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name=op.f('student_progress_user_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('student_progress_pkey'))
    )
    op.create_index(op.f('ix_student_progress_user_id'), 'student_progress', ['user_id'], unique=False)
    op.create_index(op.f('ix_student_progress_subject_id'), 'student_progress', ['subject_id'], unique=False)
    op.create_index(op.f('ix_student_progress_id'), 'student_progress', ['id'], unique=False)
    op.create_table('user_role_assignments',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('role', postgresql.ENUM('ADMIN', 'INSTRUCTOR', 'STUDENT', name='userrole'), autoincrement=False, nullable=False),
    sa.Column('domain_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('class_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('assigned_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('assigned_by', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['assigned_by'], ['auth.users.id'], name=op.f('user_role_assignments_assigned_by_fkey'), ondelete='SET NULL'),
    sa.ForeignKeyConstraint(['class_id'], ['classes.id'], name=op.f('user_role_assignments_class_id_fkey')),
    sa.ForeignKeyConstraint(['domain_id'], ['domains.id'], name=op.f('user_role_assignments_domain_id_fkey')),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name=op.f('user_role_assignments_user_id_fkey'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('user_role_assignments_pkey'))
    )
    op.create_index(op.f('ix_user_role_assignments_id'), 'user_role_assignments', ['id'], unique=False)
    op.create_table('test_statistics',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('test_id', sa.VARCHAR(), autoincrement=False, nullable=False),
    sa.Column('test_title', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('instructor_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('subject_id', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('total_attempts', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('completed_attempts', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('unique_students', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('average_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('median_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('highest_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('lowest_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('passed_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('failed_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('pass_rate', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('average_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('fastest_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('slowest_time', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('last_calculated', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name=op.f('test_statistics_pkey'))
    )
    op.create_index(op.f('ix_test_statistics_test_id'), 'test_statistics', ['test_id'], unique=False)
    op.create_index(op.f('ix_test_statistics_subject_id'), 'test_statistics', ['subject_id'], unique=False)
    op.create_index(op.f('ix_test_statistics_id'), 'test_statistics', ['id'], unique=False)
    op.create_table('item_bank',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('question_text', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('question_type', postgresql.ENUM('MULTIPLE_CHOICE', 'TRUE_FALSE', 'SHORT_ANSWER', 'ESSAY', 'FILL_IN_BLANK', name='questiontype'), autoincrement=False, nullable=False),
    sa.Column('options', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('correct_answer', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('explanation', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('points', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True),
    sa.Column('difficulty_level', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('subject_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('created_by', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('tags', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('usage_count', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['created_by'], ['auth.users.id'], name=op.f('item_bank_created_by_fkey'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['subject_id'], ['library_subjects.id'], name=op.f('item_bank_subject_id_fkey')),
    sa.PrimaryKeyConstraint('id', name=op.f('item_bank_pkey'))
    )
    op.create_index(op.f('ix_item_bank_id'), 'item_bank', ['id'], unique=False)
    # ### end Alembic commands ###
